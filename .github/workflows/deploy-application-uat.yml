# .github/workflows/deploy-application-uat.yml
name: Deploy Application - UAT

on:
  repository_dispatch:
    types: [deploy-backend]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Docker image tag to deploy (e.g., v1.2.3 or latest)"
        required: true
        default: "latest"
      run_migrations:
        description: "Run database migrations"
        required: true
        type: boolean
        default: true

permissions:
  id-token: write
  contents: read

env:
  ENVIRONMENT: uat
  IMAGE_TAG: ${{ github.event.inputs.image_tag || github.event.client_payload.version || 'latest' }}
  RUN_MIGRATIONS: ${{ github.event.inputs.run_migrations || 'true' }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment:
      name: UAT
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::341126269796:role/github-actions-role
          aws-region: eu-west-3

      - name: Get Lightsail IP from SSM
        id: get-ip
        run: |
          LIGHTSAIL_IP=$(aws ssm get-parameter --name "/default/lightsail/public_ip" --query "Parameter.Value" --output text)
          echo "lightsail_ip=$LIGHTSAIL_IP" >> $GITHUB_OUTPUT
          echo "Deploying to: $LIGHTSAIL_IP"

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.AWS_EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.get-ip.outputs.lightsail_ip }} >> ~/.ssh/known_hosts

      - name: Checkout Backend Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/lookresto # Change to your backend repo name
          token: ${{ secrets.BACKEND_REPO_PAT || github.token }}
          path: backend

      - name: Copy Migrations to Server
        run: |
          echo "üì¶ Copying migration files to server..."
          
          # Create migrations directory on server if it doesn't exist
          ssh -i ~/.ssh/id_rsa ubuntu@${{ steps.get-ip.outputs.lightsail_ip }} \
            'mkdir -p /opt/app/migrations'
          
          # Copy each module's migrations
          for module in restaurant kernel notification shared user; do
            if [ -d "backend/$module/migrations" ]; then
              echo "Copying $module migrations..."
              scp -i ~/.ssh/id_rsa -r \
                backend/$module/migrations \
                ubuntu@${{ steps.get-ip.outputs.lightsail_ip }}:/opt/app/migrations/$module
            fi
          done

      - name: Run Database Migrations
        if: env.RUN_MIGRATIONS == 'true'
        run: |
          echo "üîÑ Running migrations..."
          ssh -i ~/.ssh/id_rsa ubuntu@${{ steps.get-ip.outputs.lightsail_ip }} << 'EOF'
            cd /opt/app
            
            # Run migrations for each module
            for module in restaurant kernel notification shared user; do
              if [ -d "migrations/$module" ]; then
                echo "Running migrations for $module..."
                docker run --rm \
                  --network host \
                  -v $(pwd)/migrations/$module:/migrations \
                  migrate/migrate:latest \
                  -path=/migrations \
                  -database "${{ secrets.UAT_DB_URL }}?x-migrations-table=${module}_migrations" up
              fi
            done
          EOF

      - name: Deploy Application
        run: |
          echo "üöÄ Deploying application version: ${{ env.IMAGE_TAG }}"
          ssh -i ~/.ssh/id_rsa ubuntu@${{ steps.get-ip.outputs.lightsail_ip }} << EOF
            cd /opt/app
            
            # Pull new image
            docker pull ghcr.io/${{ github.repository_owner }}/backend:${{ env.IMAGE_TAG }}
            
            # Update docker-compose
            export BACKEND_IMAGE=ghcr.io/${{ github.repository_owner }}/backend:${{ env.IMAGE_TAG }}
            export DB_URL="${{ secrets.UAT_DB_URL }}"
            export REDIS_URL="${{ secrets.UAT_REDIS_URL }}"
            
            # Deploy with zero-downtime
            docker-compose -f docker-compose.uat.yml up -d --no-deps backend
            
            # Wait for health check
            sleep 10
          EOF

      - name: Health Check
        run: |
          echo "üè• Running health check..."
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -sf "${{ secrets.UAT_APP_URL }}/health" > /dev/null; then
              echo "‚úÖ Health check passed!"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for application... ($RETRY_COUNT/$MAX_RETRIES)"
            sleep 5
          done
          
          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          exit 1

      - name: Deployment Summary
        if: success()
        run: |
          echo "### ‚úÖ Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** UAT" >> $GITHUB_STEP_SUMMARY
          echo "**Image:** ghcr.io/${{ github.repository_owner }}/backend:${{ env.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** ${{ secrets.UAT_APP_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed by:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY

      - name: Notify Slack
        if: always()
        uses: 8398a7/action-slack@v3
        continue-on-error: true
        with:
          status: ${{ job.status }}
          text: |
            UAT Deployment: ${{ job.status }}
            Version: ${{ env.IMAGE_TAG }}
            Deployed by: ${{ github.actor }}
            URL: ${{ secrets.UAT_APP_URL }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Rollback on Failure
        if: failure()
        run: |
          echo "‚ö†Ô∏è Deployment failed, initiating rollback..."
          ssh -i ~/.ssh/id_rsa ubuntu@${{ steps.get-ip.outputs.lightsail_ip }} << 'EOF'
            cd /opt/app
            docker-compose -f docker-compose.uat.yml down
            docker-compose -f docker-compose.uat.yml up -d
          EOF
